
<!DOCTYPE html>

<html>

<head>
<style>
	#angleInfo {
		position: absolute;
		bottom: 100px; width: 100%;
		color: #ffffff;
		text-align: center;
	}

</style>
</head>

<body> 
<div id="angleInfo"> </div>
<script src="http://cdnjs.cloudflare.com/ajax/libs/three.js/r70/three.min.js"></script>
<script>
// new contact problem:
// static XZ plane
// moving gravity vector (subject to deviceOrientation)
// add shadow map

var camera, scene, renderer,light;
var ball, plane;
var clock = new THREE.Clock();
var mouse = new THREE.Vector2();
var gravity = new THREE.Vector3 ();
var gamma = 0, beta = 0;

// class defintions here
var Ball = function () {
    // properties
    this.pos = new THREE.Vector3(0, 0, 0);
    this.vel = new THREE.Vector3();
    this.force = new THREE.Vector3();
    this.mesh = new THREE.Mesh(new THREE.SphereGeometry(10, 12, 12), new THREE.MeshPhongMaterial({
        color: 0xff1234,
        specular: 0x444444,
        shininess: 80
    }));
    scene.add(this.mesh);

    // methods
    this.update = function (dt) {
        this.vel.add(this.force.clone().multiplyScalar(dt));
        this.pos.add(this.vel.clone().multiplyScalar(dt));
        this.mesh.position.copy(this.pos);
    }
}

var Plane = function () {
    // properties
    this.pos = new THREE.Vector3(0, 10, 0); // object frame
    this.normal = new THREE.Vector3(0, 1, 0); // object frame
    this.mesh = new THREE.Mesh(new THREE.BoxGeometry(500, 20, 500), new THREE.MeshLambertMaterial({
        transparent: true,
        opacity: 0.5
    }));
    scene.add(this.mesh);

    // methods
    this.isPointOut = function (point) {
        // considering plane transformation
        var posW = this.pos.clone(); // in world frame
        var normalW = this.normal.clone();
        posW.applyMatrix4(this.mesh.matrixWorld);
        var tt = new THREE.Matrix4();
        normalW.applyMatrix4(tt.getInverse(this.mesh.matrixWorld).transpose());

        return true; // for infinite plane
        // for contact problem, this should check whether the ball
        // rolls out of boundary
    }
};


init();
animate();

function ProjVonU(v, u) { // v & u unchanged!
    var uhat = u.clone().normalize();
    return uhat.multiplyScalar(uhat.dot(v));
}

function Contact(ball, plane) {
	// plane is immbile
    // considering plane transformation
  //  var posW = plane.pos.clone(); // plane in world frame
  //  var normalW = plane.normal.clone();
  //  posW.applyMatrix4(plane.mesh.matrixWorld);
  //  var tt = new THREE.Matrix4();
 //   tt.getInverse(plane.mesh.matrixWorld).transpose();
 //   normalW.applyMatrix4(tt);
/*
    // position correction
    var tmp = ball.pos.clone();
    tmp.sub(posW);
    tmp.sub(ProjVonU(tmp, normalW)).add(posW);
    ball.pos.copy(tmp);
    // lift up 10 unit (ball radius) along normalW
    ball.pos.add (normalW.clone().multiplyScalar (10));
*/
    ball.pos.setY (0);
    // contact force
    ball.force.copy (gravity); // gravity
    var normalW = new THREE.Vector3 (0,1,0);
    ball.force.add(ProjVonU(ball.force, normalW).multiplyScalar(-1)); // contact force
}

function init() {
    scene = new THREE.Scene();

camera = new THREE.OrthographicCamera (-110,110,110,-110, 10, 2000);
 camera.position.set (0,450,0);
 camera.up.set (0,0,-1);
 camera.lookAt (new THREE.Vector3(0,0,0));
    scene.add(camera);

    ball = new Ball();
 //   plane = new Plane();

    light = new THREE.PointLight(0xffffff);
    light.position.set(100, 300, 200);
    scene.add(light);

    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x888888);
    
   var gridXZ = new THREE.GridHelper(100, 10);
    gridXZ.setColors(new THREE.Color(0xff0000), new THREE.Color(0xffffff));
    scene.add(gridXZ);
    
    document.body.appendChild(renderer.domElement);
    window.addEventListener('resize', onWindowResize, false);
    document.addEventListener('mousemove', onDocumentMouseMove, false);
	angleInfoElement = document.getElementById ('angleInfo');
/*	
	if (window.DeviceOrientationEvent) {
		window.addEventListener('deviceorientation', function(e) {
			gamma = e.gamma;
			beta = e.beta;
			console.log ('do: ' + gamma +', ' + beta + ', ' + e.alpha);
		});	
	}
*/	
}

function onDocumentMouseMove(event) {
    event.preventDefault();
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1; // [-1,1]
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;


	// mouse.x is gamma (rotation about Y)
//    var a = new THREE.Euler( mouse.y/3, 0, mouse.x/3, 'XYZ' );
//    gravity = new THREE.Vector3(0,-20,0);
//    gravity.applyEuler (a);
	gamma = mouse.x;
	beta = mouse.y;
	
	console.log (gamma + ', ' +beta);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
	if (window.DeviceOrientationEvent) {
		angleInfoElement.innerHTML = gamma.toFixed(2) + ', ' + beta.toFixed(2);
	} else {
	angleInfoElement.innerHTML = 'm: ' + gamma.toFixed(2) + ', ' + beta.toFixed(2);
	}

    var a = new THREE.Euler( gamma/3, 0, beta/3, 'XYZ' );
    gravity = new THREE.Vector3(0,-20,0);
    gravity.applyEuler (a);
    Contact(ball, plane);

    var dt = clock.getDelta();
    ball.update(dt);
    
    //plane.mesh.position.set (0,-210,0);

    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}


/*
var camera, scene, renderer, geometry, material, mesh, light, controls;
var angleInfoEle;
var gamma = 0, beta = 0;

init();
animate();

function init() {
    scene = new THREE.Scene();
angleInfoEle = window.document.getElementById ('angleInfo');

    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.z = 500;
    scene.add(camera);

    geometry = new THREE.BoxGeometry(100, 20, 20);
    material = new THREE.MeshLambertMaterial();

    mesh = new THREE.Mesh(geometry, material);
    scene.add(mesh);

    light = new THREE.PointLight(0xffffff);
    light.position.set(100, 300, 200);
    scene.add(light);

    var gridXZ = new THREE.GridHelper(100, 10);
    gridXZ.setColors(new THREE.Color(0xff0000), new THREE.Color(0xffffff));
    scene.add(gridXZ);

    renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x888888);

    controls = new THREE.OrbitControls(camera, renderer.domElement);

    document.body.appendChild(renderer.domElement);
    window.addEventListener('resize', onWindowResize, false);
	window.addEventListener('deviceorientation', function(e) {
	gamma = e.gamma;
	beta = e.beta;
	console.log (gamma +', ' + beta + ', ' + e.alpha);});
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
	if (window.DEviceOrientationEvent) {
		angleInfoEle.innerHTML = gamma. + ', ' + beta;
	} else {
		angleInfoEle.innerHTML = 'not available';
	}

// gravity: (0,-10,0).applyEuler (...)
// 2D mouse movement to simulate orientation
// apply to contact problem, with static (local) platform
    controls.update();
    requestAnimationFrame(animate);
    render();
}

function render() {
    renderer.render(scene, camera);
}
*/
</script>
</body>

</html>
